
## PURPOSE: 
# This program parses through the captures generated by 'capture sequence.tap' and finds any missing
# data. The missing data can be a product of two types; type 1: misfires during the capture sequence, 
# type 2: the capture session ends early. This program catches both error types, then generates a gcode
# script ('errorCorrection.tap') to re-capture the missing data. Also, a text file is output 

import os
import time
from glob import glob
import numpy as np

numberOfCaptures = 6
spanMM = 350
quantizationIncriment = 5
numberOfCapturesPerCycle = int(spanMM/quantizationIncriment)+1
measuredTimeBetweenCaptures = 2.5 # 3.358
overflowPadding = 18
numberOfExpectedCaptures = int(numberOfCaptures*(spanMM/quantizationIncriment+1))

print(" ")
input_directory = r"C:\Users\jacob\Documents\Uncertainty Study Data Backup\iPhone 13 Pro - Cleo Burnstad\Experiment_1\Captures"

imageNames = sorted(glob(os.path.join(input_directory, "*.png")))
depthNames = sorted(glob(os.path.join(input_directory, "*.tiff")))

def getTimeFromFilename(fname: str):
    time = os.path.split(fname)[-1]
    time = os.path.splitext(time)[0]
    time = time.split('_')[1]
    return float(time)

def buildTimeList(filenames: list):
    times = []
    for filename in filenames:
        time = getTimeFromFilename(filename)
        times.append(time)
    return times

# Make a super list with all of the times a depth map or image was saved:
imageTimes = buildTimeList(imageNames)
depthTimes = buildTimeList(depthNames)
captureTimeSet = set(imageTimes + depthTimes)
captureTimes = sorted(list(captureTimeSet))

print(" ")
print("NUMBER OF CAPTURES: {}".format(len(captureTimes)))
print(" ")

# Check to make sure that all images and depths are paired
failedSaves = 0

imageTimeSet = set(imageTimes)
missedImageSaves = sorted(list(captureTimeSet - imageTimeSet))
for missedImageSave in missedImageSaves:
    print("Image at time: {} failed to save.".format(missedImageSave))
    failedSaves += 1


depthTimeSet = set(depthTimes)
missedDepthSaves = sorted(list(captureTimeSet - depthTimeSet))
for missedDepthSave in missedDepthSaves:
    print("Depth at time: {} failed to save.".format(missedDepthSave))
    failedSaves += 1

# Check to find if there were any misfires
failedCaputres = [] # indexes of all of the failed captures
timeStampList = [] # new time stamps for output files, listed sequentially
pt = captureTimes[0]
for i,nt in enumerate(captureTimes[1:]):
    if not (nt - pt) <= np.ceil(measuredTimeBetweenCaptures):

        numberOfMisses = int(np.floor((nt - pt)/np.floor(measuredTimeBetweenCaptures))) - 1

        misses = []
        for j in range(numberOfMisses):
            misses.append(i+j+1)
            failedCaputres.append(i+1)
            timeStampList.append(pt + (j+1)*measuredTimeBetweenCaptures)

        if numberOfMisses != 0:
            print("MISSED {} CAPTURES AT INDEX: {}, error: {}, filename: {}".format(numberOfMisses, misses, nt-pt, nt))

    pt = nt

# Write GCODE to handle the failed captures
nCaptures = len(captureTimes)
missingCaptures = numberOfExpectedCaptures - nCaptures
endMisses = missingCaptures - len(failedCaputres)
if endMisses > numberOfCapturesPerCycle:
    print("More than an entire cycle was missed due to an early machine halt (end misses). Retake the test with more padding.")
    exit()

# Add end misses to the time stamp list for files to be later renamed:
for i in range(endMisses):
    baseTime = captureTimes[-1]
    timeStampList.append(baseTime + (i+1)*measuredTimeBetweenCaptures)

timestamp = time.time()

open('pythonGeneratedGCODE.txt', 'w').close()
with open('errorCorrection.tap', 'w') as f:
    
    # Write file header:
    f.write("( ERROR CORRECTION SCRIPT )\n")
    f.write("( TIMESTAMP: {} )\n".format(timestamp))

    # Start the machine:
    f.write("( MACHINE START )\n")
    f.write("G21\n")
    f.write("G90\n")
    f.write("F150\n")
    f.write("S17000\n")
    f.write("M03\n")
    f.write("G00  X0.000  Y0.000 Z0.000\n")
    f.write("G04 P1\n")

    # Retake the failed captures:
    for i in range(len(failedCaputres)):

        index = failedCaputres[i] + i
        acendingOrDecending = index%(numberOfCapturesPerCycle*2) # this should be 2 times the number of captures per cycle
        positionIndex = acendingOrDecending%numberOfCapturesPerCycle # this should be the number of captures per cycle
        
        # if aceding
        if acendingOrDecending < numberOfCapturesPerCycle:
            position = -positionIndex*quantizationIncriment
            previousPosition = -(positionIndex-1)*quantizationIncriment
            if previousPosition > 0: previousPosition = 0
        
        # if decending
        else:
            position = -(spanMM - (positionIndex*quantizationIncriment))
            previousPosition = -(spanMM - ((positionIndex-1)*quantizationIncriment))
            if previousPosition < -spanMM: previousPosition = -spanMM

        f.write("( CAPTURE NUMBER: {} )\n".format(index))
        f.write("G00 X.000 Y{}.000 Z0.000\n".format(previousPosition))
        f.write("G04 P0.8\n")
        f.write("G00 X0.000 Y{}.000 Z0.000\n".format(position))
        f.write("G04 P.3\n")
        f.write("S18000\n")
        f.write("G04 P.25\n")
        f.write("S17000\n")
        f.write("G04 P.6\n")

    # Retake the failed endpoints:
    f.write("( MOVE TO ENDPOINT START )\n")
    f.write("G00 X.000 Y{}.000 Z0.000\n".format(-5*(endMisses)))
    f.write("G04 P0.8\n")
    for i in range(endMisses):
        f.write("( CAPTURE NUMBER: {} )\n".format( (numberOfExpectedCaptures-1) - (endMisses-1-i) ))
        f.write("G00 X0.000 Y{}.000 Z0.000\n".format(-5*(endMisses-1-i)))
        f.write("G04 P.3\n")
        f.write("S18000\n")
        f.write("G04 P.25\n")
        f.write("S17000\n")
        f.write("G04 P.6\n")

    # Add overflow:
    for i in range(int(overflowPadding/2)):
        f.write("( OVERFLOW: {} )\n".format(2*i))
        f.write("G04 P1\n")
        f.write("G01 X0.000 Y0.000 Z5.000\n")
        f.write("G04 P1\n")
        f.write("( OVERFLOW: {} )\n".format(2*i+1))
        f.write("G04 P1\n")
        f.write("G01 X0.000 Y0.000 Z0.000\n")
        f.write("G04 P1\n")

    # Stop the machine: 
    f.write("( MACHINE END )\n")
    f.write("G04 P0.8\n")
    f.write("G00 X0.000 Y0.000 Z5.080\n")
    f.write("G00  Z20.320\n")
    f.write("G00  X0.000  Y0.000\n")
    f.write("M02\n")

# Create text file containing file renaming convention
with open('sequentialFilenameCorrections.txt','w') as f:
    f.write('FILENAME CORRECTIONS:\n')
    f.write('rename the errorCorrection.tap files to the following, IN ORDER:\n')
    f.write('FILE TIMESTAMP: {}\n'.format(timestamp))
    f.write('\n')
    for timeFileName in timeStampList:
        f.write(str(timeFileName))
        f.write('\n')

print(" ")
print("Script complete. Failed saves: {}, missed scans: {}, skipped end scans: {}.".format(failedSaves, len(failedCaputres), endMisses))
print("Timestamp on gcode: {}".format(timestamp))
print(" ")
